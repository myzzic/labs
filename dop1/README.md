E - энергия, 

k - кол-во информационных симоволов, 

N - передаваемых кодовых слов, 

g(x) - порождающий многочлен,

codes - массив кодовых слов, полученный из функции codeBook codeBook(k, gX): 
r - макс степень многочлена g(x), 
n - длина кодового слова, 
R - смещение, 

K - кол-во кодовых слов. 

Переводим в цикле числа из 10-ой СС в 2-ую СС, далее используем реверс, чтобы старшие биты были слева, после складываем этот результат с 
остатком от деления его же на g(x). 

modGx(m_rX, gX): [~, r] = deconv(m_rX, gX); - данная функция возвращает целую часть и остаток от деления 1-го параметра на 2-ой. 
Поскольку нам важен только остаток, вместо первой переменной напишем ~. 

Далее создаём массивы соотношений сигнал/шум, массив ошибок на бит и массив ошибок декодера для разных соотношений сигнал/шум. Затем 
используется parfor для создания многопоточности, чтобы ускорить процесс моделирования программы внутри него вызывается метод model, 
который возвращает 2 значения: ошибку декодера и ошибку на бит для данного соотношения сигнал/шум. 

model(k, gX, codes, sigma, N): цикл идёт по кол-ву отправляемых кодовых слов. Случайно выбирается кодовое слово из массива codes, далее 
меняем 1 на -1, а 0 на 1. После прибавляем к полученному массиву шум. 

Далее на приёмной стороне проверяем каждый элемент: если он меньше нуля, то в новый массив на эту позицию пишем 1, иначе 0. Затем 
сверяем полученный результат с изначально отправленным, накидывая счётчик ошибок в переменную flag_sum. Если она будет больше нуля, но 
остаток от деления полученного многочлена на gX будет нулевым, то мы видим, что декодер вынес ошибочное решение. Прибавляем кол-во  
ошибочных бит. В конце усредняем значения. 
Подсчитываем теоритические значения.
